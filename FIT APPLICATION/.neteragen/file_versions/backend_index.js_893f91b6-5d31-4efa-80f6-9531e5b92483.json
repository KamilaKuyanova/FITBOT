{
  "file_name": "backend/index.js",
  "revision_id": "893f91b6-5d31-4efa-80f6-9531e5b92483",
  "metadata": {
    "timestamp": "2025-12-19T13:13:41.332990",
    "type": "cache_version",
    "source": "initial",
    "size": 24821,
    "is_reverted": false,
    "git_branch_name": "",
    "agent_name": "Cody",
    "description": null
  },
  "content": "import express from 'express';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst app = express();\nconst PORT = process.env.PORT || 3001;\n\n// Middleware\napp.use(cors());\napp.use(express.json());\n\n// Mock user wardrobe data (in production, this would come from a database)\nconst mockWardrobeData = {\n  totalItems: 128,\n  totalOutfits: 42,\n  categories: {\n    tops: 45,\n    bottoms: 32,\n    shoes: 28,\n    accessories: 23\n  },\n  stylePreferences: [\"Casual\", \"Chic\", \"Minimalist\"]\n};\n\n// AI Chat Endpoint\napp.post('/api/ai/chat', async (req, res) => {\n  try {\n    const { message, context } = req.body;\n    \n    if (!message) {\n      return res.status(400).json({ error: 'Message is required' });\n    }\n\n    // Simulate AI processing delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Generate context-aware response\n    const response = generateAIResponse(message, context || mockWardrobeData);\n\n    res.json({\n      response,\n      timestamp: new Date().toISOString()\n    });\n  } catch (error) {\n    console.error('Chat error:', error);\n    res.status(500).json({ error: 'Failed to process chat message' });\n  }\n});\n\n// AI Response Generator (Context-aware)\nfunction generateAIResponse(userMessage, wardrobeData) {\n  const message = userMessage.toLowerCase();\n  const { totalItems, totalOutfits, categories, stylePreferences } = wardrobeData;\n\n  // Greeting responses\n  if (message.includes('hello') || message.includes('hi') || message.includes('hey')) {\n    return `Hello! I'm your AI style assistant. I can see you have ${totalItems} items in your wardrobe and ${totalOutfits} saved outfits. Your style preferences include ${stylePreferences.join(', ')}. How can I help you today?`;\n  }\n\n  // Inventory queries\n  if (message.includes('inventory') || message.includes('items') || message.includes('wardrobe')) {\n    return `Your wardrobe summary:\\nâ€¢ ${categories.tops} Tops\\nâ€¢ ${categories.bottoms} Bottoms\\nâ€¢ ${categories.shoes} Pairs of Shoes\\nâ€¢ ${categories.accessories} Accessories\\nâ€¢ Total: ${totalItems} Items\\nâ€¢ ${totalOutfits} Saved Outfits\\n\\nYour style: ${stylePreferences.join(', ')}\\n\\nWhat would you like to know about your wardrobe?`;\n  }\n\n  // Outfit creation requests\n  if (message.includes('outfit') && (message.includes('create') || message.includes('make') || message.includes('suggest'))) {\n    const eventType = message.includes('evening') ? 'evening' : \n                     message.includes('business') ? 'business' :\n                     message.includes('casual') ? 'casual' : 'general';\n    \n    if (eventType === 'evening' && message.includes('chic')) {\n      return `For a chic evening event, I recommend pairing one of your elegant pieces with accessories. Based on your ${totalItems} items, I suggest: a sophisticated top from your collection, paired with statement accessories. Would you like me to show you specific combinations?`;\n    }\n    return `I can help you create a ${eventType} outfit! You have ${categories.tops} tops, ${categories.bottoms} bottoms, and ${categories.shoes} pairs of shoes to work with. What's the occasion?`;\n  }\n\n  // Style recommendations\n  if (message.includes('what should i wear') || message.includes('recommend')) {\n    if (message.includes('business casual') || message.includes('meeting')) {\n      return `For a business casual meeting, I recommend: a professional top (you have ${categories.tops} options), paired with tailored bottoms (${categories.bottoms} available), and comfortable yet polished shoes. Your minimalist style preference works perfectly for this!`;\n    }\n    return `Based on your ${totalItems} items and ${stylePreferences.join(', ')} style preferences, I can suggest several options. What's the occasion or weather like today?`;\n  }\n\n  // Matching requests\n  if (message.includes('match') || message.includes('pair')) {\n    return `I can help you match items! You have ${categories.tops} tops, ${categories.bottoms} bottoms, and ${categories.shoes} pairs of shoes. Which item would you like to match? For example, \"Match my blue shirt\" or \"What goes with my white sneakers?\"`;\n  }\n\n  // Style tips\n  if (message.includes('style') && message.includes('tip')) {\n    return `Here's a style tip based on your preferences:\\n\\nSince you love ${stylePreferences.join(' and ')}, try mixing textures and subtle patterns. With ${totalItems} items, you can create ${totalOutfits}+ unique combinations. Remember: less is more with minimalist style - focus on quality pieces that work together!`;\n  }\n\n  // Default responses\n  const defaultResponses = [\n    `I understand you're asking about \"${userMessage}\". Based on your wardrobe of ${totalItems} items and your ${stylePreferences.join(', ')} style, I can help you with outfit suggestions, item matching, or style advice. What specifically would you like help with?`,\n    `Great question! With ${totalItems} items in your closet and ${totalOutfits} saved outfits, you have plenty of options. Would you like me to suggest a specific outfit combination or help you find items that match?`,\n    `I'm here to help with your style! You have ${categories.tops} tops, ${categories.bottoms} bottoms, and ${categories.shoes} pairs of shoes. Try asking me to \"create an outfit for [occasion]\" or \"show me my [color/style] items\".`,\n  ];\n\n  return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];\n}\n\n// Profile Endpoints\napp.get('/api/profile', async (req, res) => {\n  try {\n    // In production, this would fetch from a database\n    // For now, return mock data or empty profile\n    res.json({\n      userProfile: {\n        personalInfo: {\n          name: \"Kamila Martinez\",\n          bio: \"\",\n          gender: \"Prefer not to say\",\n          avatarUrl: \"\"\n        },\n        measurements: {\n          height: { value: 165, unit: \"cm\" },\n          weight: { value: 60, unit: \"kg\" },\n          bodyType: \"Hourglass\",\n          sizeSystem: \"US\",\n          clothingSizes: {\n            shirt: \"M\",\n            pants: \"M\",\n            shoes: \"8\",\n            dress: \"M\"\n          }\n        },\n        location: {\n          city: \"New York\",\n          country: \"United States\",\n          coordinates: { lat: 40.7128, lon: -74.0060 },\n          timezone: \"America/New_York\"\n        },\n        weatherPreferences: {\n          unit: \"celsius\",\n          enabled: true,\n          notifications: true,\n          sensitivity: 5\n        },\n        stylePreferences: {\n          tags: [\"Casual\", \"Chic\", \"Minimalist\"],\n          colorPalette: [\"#F5DCE7\", \"#E3F0FF\", \"#E8F5E9\", \"#C8A2C8\"],\n          patterns: [\"Solids\"],\n          formalityLevel: 5\n        },\n        aiSettings: {\n          assistantName: \"Style Assistant\",\n          creativity: 6,\n          verbosity: 5,\n          learningFrequency: \"Daily\"\n        },\n        notifications: {\n          enabled: true,\n          emailEnabled: true,\n          types: [\"outfit_suggestions\", \"weather_alerts\"],\n          quietHours: { start: \"22:00\", end: \"08:00\" }\n        },\n        privacy: {\n          shareData: false,\n          publicOutfits: false\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Profile fetch error:', error);\n    res.status(500).json({ error: 'Failed to fetch profile' });\n  }\n});\n\napp.post('/api/profile/update', async (req, res) => {\n  try {\n    const { userProfile } = req.body;\n    \n    if (!userProfile) {\n      return res.status(400).json({ error: 'Profile data is required' });\n    }\n\n    // In production, this would save to a database\n    // For now, just return success\n    console.log('Profile updated:', userProfile);\n    \n    res.json({\n      success: true,\n      message: 'Profile updated successfully',\n      userProfile\n    });\n  } catch (error) {\n    console.error('Profile update error:', error);\n    res.status(500).json({ error: 'Failed to update profile' });\n  }\n});\n\n// Location/Weather Endpoint\napp.get('/api/weather/location', async (req, res) => {\n  try {\n    const { city } = req.query;\n    \n    if (!city) {\n      return res.status(400).json({ error: 'City is required' });\n    }\n\n    // Using OpenWeatherMap Geocoding API\n    const API_KEY = process.env.OPENWEATHER_API_KEY || process.env.VITE_WEATHER_API_KEY;\n    \n    if (!API_KEY || API_KEY === 'demo_key') {\n      // Return mock data if API key not configured\n      return res.json({\n        city: city,\n        country: \"United States\",\n        coordinates: { lat: 40.7128, lon: -74.0060 },\n        timezone: \"America/New_York\"\n      });\n    }\n\n    const GEOCODE_URL = `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(city)}&limit=1&appid=${API_KEY}`;\n    \n    const response = await fetch(GEOCODE_URL);\n    \n    if (!response.ok) {\n      throw new Error('Geocoding API error');\n    }\n\n    const data = await response.json();\n    \n    if (data.length === 0) {\n      return res.status(404).json({ error: 'Location not found' });\n    }\n\n    const location = data[0];\n    \n    res.json({\n      city: location.name,\n      country: location.country,\n      coordinates: {\n        lat: location.lat,\n        lon: location.lon\n      },\n      timezone: \"UTC\" // In production, use a timezone API\n    });\n  } catch (error) {\n    console.error('Location search error:', error);\n    res.status(500).json({ error: 'Failed to search location' });\n  }\n});\n\n// AI Reset Endpoint\napp.post('/api/ai/reset', async (req, res) => {\n  try {\n    // In production, this would reset AI learning data in the database\n    console.log('AI learning reset requested');\n    \n    res.json({\n      success: true,\n      message: 'AI learning has been reset'\n    });\n  } catch (error) {\n    console.error('AI reset error:', error);\n    res.status(500).json({ error: 'Failed to reset AI learning' });\n  }\n});\n\n// Health check endpoints\napp.get('/health', (req, res) => {\n  res.json({ ok: true, timestamp: new Date().toISOString() });\n});\n\napp.get('/api/health', (req, res) => {\n  res.json({ status: 'ok', service: 'FITBOT AI Backend' });\n});\n\n// ============================================\n// WARDROBE API ENDPOINTS\n// ============================================\n\n// Mock wardrobe items storage (in production, this would be a database)\nlet wardrobeItems = [];\n\n// GET /api/wardrobe/items - Get all items with filtering/pagination\napp.get('/api/wardrobe/items', (req, res) => {\n  try {\n    const { category, tags, color, season, condition, search, page = 1, limit = 50 } = req.query;\n    \n    let filtered = [...wardrobeItems];\n    \n    // Apply filters\n    if (category) {\n      filtered = filtered.filter(item => item.category === category);\n    }\n    \n    if (tags) {\n      const tagArray = Array.isArray(tags) ? tags : [tags];\n      filtered = filtered.filter(item => {\n        const itemTags = [...(item.tags || []), ...(item.tag ? [item.tag] : [])];\n        return tagArray.some(tag => itemTags.includes(tag));\n      });\n    }\n    \n    if (color) {\n      filtered = filtered.filter(item => item.color === color);\n    }\n    \n    if (season) {\n      const seasonArray = Array.isArray(season) ? season : [season];\n      filtered = filtered.filter(item =>\n        item.seasons?.some(s => seasonArray.includes(s))\n      );\n    }\n    \n    if (condition) {\n      const conditionArray = Array.isArray(condition) ? condition : [condition];\n      filtered = filtered.filter(item =>\n        item.condition && conditionArray.includes(item.condition)\n      );\n    }\n    \n    if (search) {\n      const searchLower = search.toLowerCase();\n      filtered = filtered.filter(item =>\n        item.name.toLowerCase().includes(searchLower) ||\n        item.brand?.toLowerCase().includes(searchLower) ||\n        item.tags?.some(tag => tag.toLowerCase().includes(searchLower))\n      );\n    }\n    \n    // Pagination\n    const start = (parseInt(page) - 1) * parseInt(limit);\n    const end = start + parseInt(limit);\n    const paginated = filtered.slice(start, end);\n    \n    res.json({\n      items: paginated,\n      total: filtered.length,\n      page: parseInt(page),\n      limit: parseInt(limit),\n      totalPages: Math.ceil(filtered.length / parseInt(limit))\n    });\n  } catch (error) {\n    console.error('Get items error:', error);\n    res.status(500).json({ error: 'Failed to fetch items' });\n  }\n});\n\n// GET /api/wardrobe/items/:id - Get single item details\napp.get('/api/wardrobe/items/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    const item = wardrobeItems.find(i => i.id === id);\n    \n    if (!item) {\n      return res.status(404).json({ error: 'Item not found' });\n    }\n    \n    res.json({ item });\n  } catch (error) {\n    console.error('Get item error:', error);\n    res.status(500).json({ error: 'Failed to fetch item' });\n  }\n});\n\n// POST /api/wardrobe/items - Create new item\napp.post('/api/wardrobe/items', (req, res) => {\n  try {\n    const itemData = req.body;\n    \n    // Validate required fields\n    if (!itemData.name || !itemData.category) {\n      return res.status(400).json({ error: 'Name and category are required' });\n    }\n    \n    const newItem = {\n      ...itemData,\n      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      wearCount: itemData.wearCount || 0,\n      isArchived: itemData.isArchived || false,\n    };\n    \n    wardrobeItems.push(newItem);\n    \n    res.status(201).json({ success: true, item: newItem });\n  } catch (error) {\n    console.error('Create item error:', error);\n    res.status(500).json({ error: 'Failed to create item' });\n  }\n});\n\n// PUT /api/wardrobe/items/:id - Update item\napp.put('/api/wardrobe/items/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    const updates = req.body;\n    \n    const itemIndex = wardrobeItems.findIndex(i => i.id === id);\n    \n    if (itemIndex === -1) {\n      return res.status(404).json({ error: 'Item not found' });\n    }\n    \n    wardrobeItems[itemIndex] = {\n      ...wardrobeItems[itemIndex],\n      ...updates,\n      updatedAt: new Date().toISOString(),\n    };\n    \n    res.json({ success: true, item: wardrobeItems[itemIndex] });\n  } catch (error) {\n    console.error('Update item error:', error);\n    res.status(500).json({ error: 'Failed to update item' });\n  }\n});\n\n// DELETE /api/wardrobe/items/:id - Delete item\napp.delete('/api/wardrobe/items/:id', (req, res) => {\n  try {\n    const { id } = req.params;\n    const itemIndex = wardrobeItems.findIndex(i => i.id === id);\n    \n    if (itemIndex === -1) {\n      return res.status(404).json({ error: 'Item not found' });\n    }\n    \n    wardrobeItems.splice(itemIndex, 1);\n    \n    res.json({ success: true, message: 'Item deleted successfully' });\n  } catch (error) {\n    console.error('Delete item error:', error);\n    res.status(500).json({ error: 'Failed to delete item' });\n  }\n});\n\n// POST /api/wardrobe/upload - Image upload endpoint\napp.post('/api/wardrobe/upload', (req, res) => {\n  try {\n    // In production, this would handle actual file upload using multer or similar\n    // For now, return mock response\n    const { imageBase64, itemId } = req.body;\n    \n    if (!imageBase64) {\n      return res.status(400).json({ error: 'Image data is required' });\n    }\n    \n    // Simulate image processing\n    const imageUrl = `https://api.example.com/images/${Date.now()}.jpg`;\n    const thumbnailUrl = `https://api.example.com/thumbnails/${Date.now()}.jpg`;\n    \n    res.json({\n      success: true,\n      imageUrl,\n      thumbnailUrl,\n      itemId: itemId || null\n    });\n  } catch (error) {\n    console.error('Upload error:', error);\n    res.status(500).json({ error: 'Failed to upload image' });\n  }\n});\n\n// GET /api/wardrobe/categories - Get all categories and subcategories\napp.get('/api/wardrobe/categories', (req, res) => {\n  try {\n    const categories = {\n      tops: [\"T-shirt\", \"Blouse\", \"Shirt\", \"Sweater\", \"Tank Top\", \"Hoodie\", \"Cardigan\", \"Crop Top\", \"Polo\", \"Tunic\"],\n      bottoms: [\"Jeans\", \"Pants\", \"Shorts\", \"Skirt\", \"Leggings\", \"Trousers\", \"Capris\", \"Joggers\", \"Sweatpants\"],\n      shoes: [\"Sneakers\", \"Boots\", \"Heels\", \"Flats\", \"Sandals\", \"Loafers\", \"Oxfords\", \"Slippers\", \"Athletic\"],\n      accessories: [\"Bag\", \"Belt\", \"Hat\", \"Scarf\", \"Jewelry\", \"Watch\", \"Sunglasses\", \"Gloves\", \"Tie\"],\n      outerwear: [\"Jacket\", \"Coat\", \"Blazer\", \"Vest\", \"Parka\", \"Trench Coat\", \"Windbreaker\", \"Bomber\"],\n      dresses: [\"Casual Dress\", \"Formal Dress\", \"Sundress\", \"Maxi Dress\", \"Midi Dress\", \"Mini Dress\", \"Wrap Dress\"],\n      activewear: [\"Sports Bra\", \"Athletic Top\", \"Athletic Shorts\", \"Yoga Pants\", \"Gym Leggings\", \"Athletic Jacket\"],\n      swimwear: [\"Swimsuit\", \"Bikini\", \"One-Piece\", \"Swim Trunks\", \"Cover-up\", \"Rash Guard\"],\n      underwear: [\"Bra\", \"Underwear\", \"Undershirt\", \"Socks\", \"Tights\", \"Shapewear\"],\n      other: [\"Other\"],\n      outfits: [\"Outfit\"],\n    };\n    \n    res.json({ categories });\n  } catch (error) {\n    console.error('Get categories error:', error);\n    res.status(500).json({ error: 'Failed to fetch categories' });\n  }\n});\n\n// GET /api/wardrobe/stats - Get wardrobe statistics\napp.get('/api/wardrobe/stats', (req, res) => {\n  try {\n    const stats = {\n      totalItems: wardrobeItems.length,\n      totalOutfits: wardrobeItems.filter(i => i.category === 'outfits').length,\n      byCategory: {\n        tops: wardrobeItems.filter(i => i.category === 'tops').length,\n        bottoms: wardrobeItems.filter(i => i.category === 'bottoms').length,\n        shoes: wardrobeItems.filter(i => i.category === 'shoes').length,\n        accessories: wardrobeItems.filter(i => i.category === 'accessories').length,\n        outerwear: wardrobeItems.filter(i => i.category === 'outerwear').length,\n        dresses: wardrobeItems.filter(i => i.category === 'dresses').length,\n        activewear: wardrobeItems.filter(i => i.category === 'activewear').length,\n        swimwear: wardrobeItems.filter(i => i.category === 'swimwear').length,\n        underwear: wardrobeItems.filter(i => i.category === 'underwear').length,\n        other: wardrobeItems.filter(i => i.category === 'other').length,\n      },\n      totalValue: wardrobeItems.reduce((sum, item) => sum + (item.price || 0), 0),\n      mostWorn: wardrobeItems\n        .filter(i => i.wearCount)\n        .sort((a, b) => (b.wearCount || 0) - (a.wearCount || 0))\n        .slice(0, 5)\n        .map(i => ({ id: i.id, name: i.name, wearCount: i.wearCount })),\n      favoriteItems: wardrobeItems.filter(i => i.isFavorite).length,\n    };\n    \n    res.json({ stats });\n  } catch (error) {\n    console.error('Get stats error:', error);\n    res.status(500).json({ error: 'Failed to fetch statistics' });\n  }\n});\n\n// Mock storage for user photos\nconst userPhotos = [];\n\n// POST /api/upload/photo - Upload photo file\napp.post('/api/upload/photo', async (req, res) => {\n  try {\n    const { imageBase64, userId } = req.body;\n    \n    if (!imageBase64) {\n      return res.status(400).json({ error: 'Image data is required' });\n    }\n\n    // Simulate file upload and storage\n    const photoId = `photo_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const imageUrl = imageBase64; // In production, upload to S3/Cloudinary and get URL\n    \n    const photo = {\n      id: photoId,\n      userId: userId || 'default_user',\n      imageUrl,\n      createdAt: new Date().toISOString(),\n      isPrimary: userPhotos.length === 0,\n    };\n\n    userPhotos.push(photo);\n\n    res.json({\n      success: true,\n      photoId,\n      imageUrl,\n      message: 'Photo uploaded successfully'\n    });\n  } catch (error) {\n    console.error('Photo upload error:', error);\n    res.status(500).json({ error: 'Failed to upload photo' });\n  }\n});\n\n// POST /api/upload/process - Process photo for measurements\napp.post('/api/upload/process', async (req, res) => {\n  try {\n    const { photoId } = req.body;\n    \n    if (!photoId) {\n      return res.status(400).json({ error: 'Photo ID is required' });\n    }\n\n    // Simulate AI processing delay\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Simulate extracted measurements\n    const measurements = {\n      height: 170 + Math.floor(Math.random() * 20) - 10, // 160-180 cm\n      shape: ['Hourglass', 'Pear', 'Apple', 'Rectangle', 'Athletic'][Math.floor(Math.random() * 5)],\n      shoulders: 36 + Math.floor(Math.random() * 6) - 3, // 33-39\"\n      bust: 34 + Math.floor(Math.random() * 6) - 3, // 31-37\"\n      waist: 28 + Math.floor(Math.random() * 6) - 3, // 25-31\"\n      hips: 36 + Math.floor(Math.random() * 6) - 3, // 33-39\"\n      inseam: 30 + Math.floor(Math.random() * 6) - 3, // 27-33\"\n    };\n\n    const photo = userPhotos.find(p => p.id === photoId);\n    if (photo) {\n      photo.processedUrl = photo.imageUrl; // In production, processed version URL\n      photo.measurements = measurements;\n      photo.poseType = 'standing';\n      photo.backgroundType = 'plain';\n    }\n\n    res.json({\n      success: true,\n      measurements,\n      processedUrl: photo?.processedUrl,\n      message: 'Photo processed successfully'\n    });\n  } catch (error) {\n    console.error('Photo processing error:', error);\n    res.status(500).json({ error: 'Failed to process photo' });\n  }\n});\n\n// GET /api/upload/history - Get user's uploaded photos\napp.get('/api/upload/history', (req, res) => {\n  try {\n    const { userId } = req.query;\n    const photos = userPhotos.filter(p => !userId || p.userId === userId);\n    \n    res.json({\n      success: true,\n      photos: photos.map(p => ({\n        id: p.id,\n        imageUrl: p.imageUrl,\n        processedUrl: p.processedUrl,\n        measurements: p.measurements,\n        createdAt: p.createdAt,\n        isPrimary: p.isPrimary,\n      }))\n    });\n  } catch (error) {\n    console.error('Get photo history error:', error);\n    res.status(500).json({ error: 'Failed to fetch photo history' });\n  }\n});\n\n// DELETE /api/upload/:photoId - Delete uploaded photo\napp.delete('/api/upload/:photoId', (req, res) => {\n  try {\n    const { photoId } = req.params;\n    const index = userPhotos.findIndex(p => p.id === photoId);\n    \n    if (index === -1) {\n      return res.status(404).json({ error: 'Photo not found' });\n    }\n\n    userPhotos.splice(index, 1);\n\n    res.json({\n      success: true,\n      message: 'Photo deleted successfully'\n    });\n  } catch (error) {\n    console.error('Delete photo error:', error);\n    res.status(500).json({ error: 'Failed to delete photo' });\n  }\n});\n\n// POST /api/ai/generate-avatar - Generate 3D avatar from photo\napp.post('/api/ai/generate-avatar', async (req, res) => {\n  try {\n    const { photoId } = req.body;\n    \n    if (!photoId) {\n      return res.status(400).json({ error: 'Photo ID is required' });\n    }\n\n    // Simulate avatar generation delay\n    await new Promise(resolve => setTimeout(resolve, 3000));\n\n    const photo = userPhotos.find(p => p.id === photoId);\n    if (!photo) {\n      return res.status(404).json({ error: 'Photo not found' });\n    }\n\n    // In production, generate 3D avatar and return URL\n    const avatarUrl = photo.imageUrl; // Placeholder\n\n    if (photo) {\n      photo.avatarUrl = avatarUrl;\n    }\n\n    res.json({\n      success: true,\n      avatarUrl,\n      message: 'Avatar generated successfully'\n    });\n  } catch (error) {\n    console.error('Avatar generation error:', error);\n    res.status(500).json({ error: 'Failed to generate avatar' });\n  }\n});\n\n// Start server\napp.listen(PORT, \"0.0.0.0\", () => {\n  console.log(`ðŸš€ FITBOT AI Backend server running on http://0.0.0.0:${PORT}`);\n  console.log(`ðŸ“¡ Server accessible at http://192.168.0.23:${PORT} on local network`);\n  console.log(`ðŸ“¡ API endpoints:`);\n  console.log(`   GET  /health - Health check`);\n  console.log(`   POST /api/ai/chat - Chat with AI assistant`);\n  console.log(`   GET  /api/profile - Get user profile`);\n  console.log(`   POST /api/profile/update - Update user profile`);\n  console.log(`   GET  /api/weather/location - Search location by city`);\n  console.log(`   POST /api/ai/reset - Reset AI learning`);\n  console.log(`   GET  /api/wardrobe/items - Get all wardrobe items`);\n  console.log(`   GET  /api/wardrobe/items/:id - Get single item`);\n  console.log(`   POST /api/wardrobe/items - Create new item`);\n  console.log(`   PUT  /api/wardrobe/items/:id - Update item`);\n  console.log(`   DELETE /api/wardrobe/items/:id - Delete item`);\n  console.log(`   POST /api/wardrobe/upload - Upload image`);\n  console.log(`   GET  /api/wardrobe/categories - Get categories`);\n  console.log(`   GET  /api/wardrobe/stats - Get wardrobe statistics`);\n  console.log(`   POST /api/upload/photo - Upload photo for virtual try-on`);\n  console.log(`   POST /api/upload/process - Process photo for measurements`);\n  console.log(`   GET  /api/upload/history - Get user's uploaded photos`);\n  console.log(`   DELETE /api/upload/:photoId - Delete uploaded photo`);\n  console.log(`   POST /api/ai/generate-avatar - Generate 3D avatar from photo`);\n});\n\n",
  "saved_at": "2025-12-19T13:13:41.332990"
}